# gcc linux 下手动debug命令总结 && 结构体和联合体的区别
#### 结构体字节内存对齐基础知识扫盲
> 即以结构体成员中占内存最多的数据类型所占的字节数为标准，所有的成员在分配内存时都要与这个长度对齐。我们举一个例子：我们以上面这个程序为例，结构体变量 data 的成员中占内存最多的数据类型是 int 型，其占 4 字节的内存空间，那么所有成员在分配内存时都要与 4 字节的长度对齐。也就是说，虽然 char 只占 1 字节，但是为了与 4 字节的长度对齐，它后面的 3 字节都会空着.

![Image text](https://raw.githubusercontent.com/fengjun2016/myGitBook/master/img_cut/struct1.png)

#### 联合体内存分配知识扫盲
> 当多个数据需要共享内存或者多个数据每次只取其一时，可以利用联合体(union)。在C Programming Language 一书中对于联合体是这么描述的： 
1)联合体是一个结构； 
2)它的所有成员相对于基地址的偏移量都为0； 
3)此结构空间要大到足够容纳最”宽”的成员； 
4)其对齐方式要适合其中所有的成员； 
下面解释这四条描述： 
由于联合体中的所有成员是共享一段内存的，因此每个成员的存放首地址相对于于联合体变量的基地址的偏移量为0，即所有成员的首地址都是一样的。为了使得所有成员能够共享一段内存，因此该空间必须足够容纳这些成员中最宽的成员。对于这句“对齐方式要适合其中所有的成员”是指其必须符合所有成员的自身对齐方式。

> s占9字节，n占4字节，d占8字节，因此其至少需9字节的空间。然而其实际大小并不是9，用运算符sizeof测试其大小为16.这是因为这里存在字节对齐的问题，9既不能被4整除，也不能被8整除。因此补充字节到16，这样就符合所有成员的自身对齐了。从这里可以看出联合体所占的空间不仅取决于最宽成员，还跟所有成员有关系，即其大小必须满足两个条件：
* 1)大小足够容纳最宽的成员；
* 2)大小能被其包含的所有基本数据类型的大小所整除。

![Image text](https://raw.githubusercontent.com/fengjun2016/myGitBook/master/img_cut/union.png)

> 测试程序如下所示
  ``` c 
  #include<stdio.h>
  int main(){
  	struct _s{  //结构体 空占并且字节对齐
		char a;  //64位机 占1个字节
		int b;   //4个字节
		long c;  //8个字节
		void* d; //8个字节
		int e;   //4个字节
		char* f; //8个字节
  	}s;
  	s.a = 'a';
  	s.b = 1;
  	s.c = 2;
  	s.d = NULL;
  	s.e = 3;
  	s.f = &s.a;
  	printf("size of struct s is %d\n", sizeof(s));
	return 0;
  }
  ```

  ``` c
  #include<stdio.h>
  int main(){
  	union _s{ //联合体 覆盖8个字节 总共只占有8个字节 元素共享同一块内存
		char a;
		int b;
		long c;
		void* d;
		int e;
		char* f;
  	}s;
  	s.a = 'a';
  	s.b = 1;
  	s.c = 2;
  	s.d = NULL;
  	s.e = 3;
  	s.f = &s.a;
  	printf("size of struct s is %d\n", sizeof(s));
	return 0;
  }
  ```

## 带gdb模式下的手动命令调试 生成二进制文件
> gcc test.c -g -o test

### 执行完上面的命令之后 进行gdb调试运行
> gdb ./test

### 使用命令b进行断点调试 比如下面在main函数处进行断点
> b main

### 然后使用命令r运行断点调试 从断点处一步一步调试运行
> r

### 使用命令p打印断点处的结构体变量s
> p s

### 然后使用命令n运行下一步
> n

### 再次打印结构体变量s
> p s

### 再次运行命令n 继续执行下一步 打印&s.a的地址
> * n
  * p &s.a

